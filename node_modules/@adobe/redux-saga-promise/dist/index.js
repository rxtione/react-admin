"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPromiseAction = createPromiseAction;
exports.implementPromiseAction = implementPromiseAction;
exports.resolvePromiseAction = resolvePromiseAction;
exports.rejectPromiseAction = rejectPromiseAction;
exports.dispatch = dispatch;
exports.promiseMiddleware = exports.ConfigurationError = exports.ArgumentError = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _effects = require("redux-saga/effects");

var _reduxActions = require("redux-actions");

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _marked = /*#__PURE__*/_regenerator["default"].mark(implementPromiseAction),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(resolvePromiseAction),
    _marked3 = /*#__PURE__*/_regenerator["default"].mark(rejectPromiseAction);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

//
// Internal helpers
//
var isTriggerAction = function isTriggerAction(action) {
  var _action$meta, _action$meta$promise;

  return ((_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : (_action$meta$promise = _action$meta.promise) === null || _action$meta$promise === void 0 ? void 0 : _action$meta$promise.resolvedAction) != null;
};

var resolvePromise = function resolvePromise(action, value) {
  return action.meta.promise.resolve(value);
};

var rejectPromise = function rejectPromise(action, error) {
  return action.meta.promise.reject(error);
};

var verify = function verify(action, method) {
  if (!isTriggerAction(action)) throw new ArgumentError("redux-saga-promise: ".concat(method, ": first argument must be promise trigger action, got ").concat(action));
  if (!(0, _isFunction["default"])(action.meta.promise.resolve)) throw new ConfigurationError("redux-saga-promise: ".concat(method, ": Unable to execute--it seems that promiseMiddleware has not been not included before SagaMiddleware"));
}; //
// Custom error class
//


var ArgumentError = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(ArgumentError, _Error);

  var _super = _createSuper(ArgumentError);

  function ArgumentError() {
    (0, _classCallCheck2["default"])(this, ArgumentError);
    return _super.apply(this, arguments);
  }

  return ArgumentError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

exports.ArgumentError = ArgumentError;

var ConfigurationError = /*#__PURE__*/function (_Error2) {
  (0, _inherits2["default"])(ConfigurationError, _Error2);

  var _super2 = _createSuper(ConfigurationError);

  function ConfigurationError() {
    (0, _classCallCheck2["default"])(this, ConfigurationError);
    return _super2.apply(this, arguments);
  }

  return ConfigurationError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error)); //
// createPromiseAction() creates the suite of actions
//
// The trigger action uses the passed payload & meta functions, and it
// appends a `promise` object to the meta.  The promise object includes the
// other lifecycle actions of the suite for use by the middleware; and
// later on the middleware will add to it functions to resolve and reject
// the promise.
//


exports.ConfigurationError = ConfigurationError;

function createPromiseAction(prefix, payload, meta) {
  var createStage = function createStage(type, payload, meta) {
    return (0, _reduxActions.createAction)("".concat(prefix, ".").concat(type), payload, meta);
  };

  var resolvedAction = createStage('RESOLVED');
  var rejectedAction = createStage('REJECTED');
  var trigger = createStage('TRIGGER', payload, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (0, _merge["default"])(meta === null || meta === void 0 ? void 0 : meta.apply(void 0, args), {
      promise: {
        resolvedAction: resolvedAction,
        rejectedAction: rejectedAction
      }
    });
  });
  var suite = trigger;
  suite.trigger = trigger;
  suite.resolved = resolvedAction;
  suite.rejected = rejectedAction;
  return suite;
} //
// Sagas to resolve & reject the promise
//


function implementPromiseAction(action, body) {
  return _regenerator["default"].wrap(function implementPromiseAction$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          verify(action, 'implementPromiseAction');
          _context.prev = 1;
          _context.t0 = resolvePromise;
          _context.t1 = action;
          _context.next = 6;
          return (0, _effects.call)(body);

        case 6:
          _context.t2 = _context.sent;
          (0, _context.t0)(_context.t1, _context.t2);
          _context.next = 13;
          break;

        case 10:
          _context.prev = 10;
          _context.t3 = _context["catch"](1);
          rejectPromise(action, _context.t3);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[1, 10]]);
}

function resolvePromiseAction(action, value) {
  return _regenerator["default"].wrap(function resolvePromiseAction$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          verify(action, 'resolvePromiseAction');
          resolvePromise(action, value);

        case 2:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}

function rejectPromiseAction(action, error) {
  return _regenerator["default"].wrap(function rejectPromiseAction$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          verify(action, 'rejectPromiseAction');
          rejectPromise(action, error);

        case 2:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
} //
// dispatch() effect creator
//
// Convenience redux-saga effect creator that chooses put() or putResolve()
// based on whether the action is a promise action.  Also allows passing
// the action creator and payload separately
//


function dispatch(action, args) {
  if ((0, _isFunction["default"])(action)) {
    action = action(args);
  } else if (action == null) {
    throw new ArgumentError('redux-saga-promise: null action passed to dispatch() effect creator');
  } else if (args !== undefined) {
    throw new ArgumentError('redux-saga-promise: extra args passed to dispatch() effect creator');
  }

  return isTriggerAction(action) ? (0, _effects.putResolve)(action) : (0, _effects.put)(action);
} //
// promiseMiddleware
//
// For a trigger action a promise is created and returned, and the action's
// meta.promise is augmented with resolve and reject functions for use
// by the sagas.  (This middleware must come before sagaMiddleware so that
// the sagas will have those functions available.)
//
// Other actions are passed through unmolested
//


var promiseMiddleware = function promiseMiddleware(store) {
  return function (next) {
    return function (action) {
      if (isTriggerAction(action)) {
        return new Promise(function (_resolve, _reject) {
          return next((0, _merge["default"])(action, {
            meta: {
              promise: {
                resolve: function resolve(value) {
                  _resolve(value);

                  store.dispatch(action.meta.promise.resolvedAction(value));
                },
                reject: function reject(error) {
                  _reject(error);

                  store.dispatch(action.meta.promise.rejectedAction(error));
                }
              }
            }
          }));
        });
      }

      return next(action);
    };
  };
};

exports.promiseMiddleware = promiseMiddleware;