import { transformToNestObject, appendErrors } from 'react-hook-form';

const parseErrorSchema = (error, validateAllFieldCriteria) => Array.isArray(error.inner) && error.inner.length
    ? error.inner.reduce((previous, { path, message, type }) => {
        const previousTypes = (previous[path] && previous[path].types) || {};
        return Object.assign(Object.assign({}, previous), (path
            ? {
                [path]: Object.assign(Object.assign({}, (previous[path] || {
                    message,
                    type,
                })), (validateAllFieldCriteria
                    ? {
                        types: Object.assign(Object.assign({}, previousTypes), { [type]: previousTypes[type]
                                ? [...[].concat(previousTypes[type]), message]
                                : message }),
                    }
                    : {})),
            }
            : {}));
    }, {})
    : {
        [error.path]: { message: error.message, type: error.type },
    };
const yupResolver = (schema, options = {
    abortEarly: false,
}) => async (values, context, validateAllFieldCriteria = false) => {
    try {
        if (options.context &&
            process.env.NODE_ENV === 'development') {
            // eslint-disable-next-line no-console
            console.warn("You should not used the yup options context. Please, use the 'useForm' context object instead");
        }
        return {
            values: (await schema.validate(values, Object.assign(Object.assign({}, options), { context }))),
            errors: {},
        };
    }
    catch (e) {
        const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);
        return {
            values: {},
            errors: validateAllFieldCriteria
                ? parsedErrors
                : transformToNestObject(parsedErrors),
        };
    }
};

var convertArrayToPathName = (paths) => paths
    .reduce((previous, path, index) => `${previous}${typeof path === 'string'
    ? `${index > 0 ? '.' : ''}${path}`
    : `[${path}]`}`, '')
    .toString();

const parseErrorSchema$1 = (error, validateAllFieldCriteria) => Array.isArray(error.failures)
    ? error.failures.reduce((previous, { path, message = '', type }) => {
        const currentPath = convertArrayToPathName(path);
        return Object.assign(Object.assign({}, previous), (path
            ? previous[currentPath] && validateAllFieldCriteria
                ? {
                    [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type || '', message),
                }
                : {
                    [currentPath]: previous[currentPath] || Object.assign({ message,
                        type }, (validateAllFieldCriteria
                        ? {
                            types: { [type || '']: message || true },
                        }
                        : {})),
                }
            : {}));
    }, {})
    : [];
const superstructResolver = (schema) => async (values, _, validateAllFieldCriteria = false) => {
    try {
        return {
            values: schema(values),
            errors: {},
        };
    }
    catch (e) {
        return {
            values: {},
            errors: transformToNestObject(parseErrorSchema$1(e, validateAllFieldCriteria)),
        };
    }
};

const parseErrorSchema$2 = (error, validateAllFieldCriteria) => Array.isArray(error.details)
    ? error.details.reduce((previous, { path, message = '', type }) => {
        const currentPath = convertArrayToPathName(path);
        return Object.assign(Object.assign({}, previous), (path
            ? previous[currentPath] && validateAllFieldCriteria
                ? {
                    [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type, message),
                }
                : {
                    [currentPath]: previous[currentPath] || Object.assign({ message,
                        type }, (validateAllFieldCriteria
                        ? {
                            types: { [type]: message || true },
                        }
                        : {})),
                }
            : {}));
    }, {})
    : [];
const joiResolver = (schema, options = {
    abortEarly: false,
}) => async (values, _, validateAllFieldCriteria = false) => {
    try {
        return {
            values: await schema.validateAsync(values, Object.assign({}, options)),
            errors: {},
        };
    }
    catch (e) {
        return {
            values: {},
            errors: transformToNestObject(parseErrorSchema$2(e, validateAllFieldCriteria)),
        };
    }
};

export { joiResolver, superstructResolver, yupResolver };
//# sourceMappingURL=index.esm.js.map
