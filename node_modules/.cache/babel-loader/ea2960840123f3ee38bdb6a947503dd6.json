{"ast":null,"code":"import { transformToNestObject, appendErrors } from 'react-hook-form';\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => Array.isArray(error.inner) && error.inner.length ? error.inner.reduce((previous, {\n  path,\n  message,\n  type\n}) => {\n  const previousTypes = previous[path] && previous[path].types || {};\n  return Object.assign(Object.assign({}, previous), path ? {\n    [path]: Object.assign(Object.assign({}, previous[path] || {\n      message,\n      type\n    }), validateAllFieldCriteria ? {\n      types: Object.assign(Object.assign({}, previousTypes), {\n        [type]: previousTypes[type] ? [...[].concat(previousTypes[type]), message] : message\n      })\n    } : {})\n  } : {});\n}, {}) : {\n  [error.path]: {\n    message: error.message,\n    type: error.type\n  }\n};\n\nconst yupResolver = (schema, options = {\n  abortEarly: false\n}) => async (values, context, validateAllFieldCriteria = false) => {\n  try {\n    if (options.context && process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\"You should not used the yup options context. Please, use the 'useForm' context object instead\");\n    }\n\n    return {\n      values: await schema.validate(values, Object.assign(Object.assign({}, options), {\n        context\n      })),\n      errors: {}\n    };\n  } catch (e) {\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: validateAllFieldCriteria ? parsedErrors : transformToNestObject(parsedErrors)\n    };\n  }\n};\n\nvar convertArrayToPathName = paths => paths.reduce((previous, path, index) => `${previous}${typeof path === 'string' ? `${index > 0 ? '.' : ''}${path}` : `[${path}]`}`, '').toString();\n\nconst parseErrorSchema$1 = (error, validateAllFieldCriteria) => Array.isArray(error.failures) ? error.failures.reduce((previous, {\n  path,\n  message = '',\n  type\n}) => {\n  const currentPath = convertArrayToPathName(path);\n  return Object.assign(Object.assign({}, previous), path ? previous[currentPath] && validateAllFieldCriteria ? {\n    [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type || '', message)\n  } : {\n    [currentPath]: previous[currentPath] || Object.assign({\n      message,\n      type\n    }, validateAllFieldCriteria ? {\n      types: {\n        [type || '']: message || true\n      }\n    } : {})\n  } : {});\n}, {}) : [];\n\nconst superstructResolver = schema => async (values, _, validateAllFieldCriteria = false) => {\n  try {\n    return {\n      values: schema(values),\n      errors: {}\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(parseErrorSchema$1(e, validateAllFieldCriteria))\n    };\n  }\n};\n\nconst parseErrorSchema$2 = (error, validateAllFieldCriteria) => Array.isArray(error.details) ? error.details.reduce((previous, {\n  path,\n  message = '',\n  type\n}) => {\n  const currentPath = convertArrayToPathName(path);\n  return Object.assign(Object.assign({}, previous), path ? previous[currentPath] && validateAllFieldCriteria ? {\n    [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type, message)\n  } : {\n    [currentPath]: previous[currentPath] || Object.assign({\n      message,\n      type\n    }, validateAllFieldCriteria ? {\n      types: {\n        [type]: message || true\n      }\n    } : {})\n  } : {});\n}, {}) : [];\n\nconst joiResolver = (schema, options = {\n  abortEarly: false\n}) => async (values, _, validateAllFieldCriteria = false) => {\n  try {\n    return {\n      values: await schema.validateAsync(values, Object.assign({}, options)),\n      errors: {}\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(parseErrorSchema$2(e, validateAllFieldCriteria))\n    };\n  }\n};\n\nexport { joiResolver, superstructResolver, yupResolver };","map":{"version":3,"sources":["../src/yup.ts","../src/utils/convertArrayToPathName.ts","../src/superstruct.ts","../src/joi.ts"],"names":["parseErrorSchema"],"mappings":";;AAGA,MAAM,gBAAgB,GAAG,CACvB,KADuB,EAEvB,wBAFuB,KAIvB,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,KAApB,KAA8B,KAAK,CAAC,KAAN,CAAY,MAA1C,GACI,KAAK,CAAC,KAAN,CAAY,MAAZ,CACE,CAAC,QAAD,EAAgC;AAAE,EAAA,IAAF;AAAQ,EAAA,OAAR;AAAiB,EAAA;AAAjB,CAAhC,KAAuD;AACrD,QAAM,aAAa,GAAI,QAAQ,CAAC,IAAD,CAAR,IAAkB,QAAQ,CAAC,IAAD,CAAR,CAAe,KAAlC,IAA4C,EAAlE;AACA,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,QADL,CAAA,EAEM,IAAI,GACJ;AACE,KAAC,IAAD,GAAK,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACC,QAAQ,CAAC,IAAD,CAAR,IAAkB;AACpB,MAAA,OADoB;AAEpB,MAAA;AAFoB,KADnB,CAAA,EAKC,wBAAwB,GACxB;AACE,MAAA,KAAK,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACA,aADA,CAAA,EACa;AAChB,SAAC,IAAD,GAAQ,aAAa,CAAC,IAAD,CAAb,GACJ,CAAC,GAAG,GAAG,MAAH,CAAU,aAAa,CAAC,IAAD,CAAvB,CAAJ,EAAoC,OAApC,CADI,GAEJ;AAHY,OADb;AADP,KADwB,GASxB,EAdD;AADP,GADI,GAmBJ,EArBN,CAAA;AAuBD,CA1BH,EA2BE,EA3BF,CADJ,GA8BI;AACE,GAAC,KAAK,CAAC,IAAP,GAAc;AAAE,IAAA,OAAO,EAAE,KAAK,CAAC,OAAjB;AAA0B,IAAA,IAAI,EAAE,KAAK,CAAC;AAAtC;AADhB,CAlCN;;MAsCa,WAAW,GAAG,CACzB,MADyB,EAEzB,OAAA,GAAgD;AAC9C,EAAA,UAAU,EAAE;AADkC,CAFvB,KAKE,OAC3B,MAD2B,EAE3B,OAF2B,EAG3B,wBAAwB,GAAG,KAHA,KAGK;AAEhC,MAAI;AACF,QACG,OAA+B,CAAC,OAAhC,IACD,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,aAF3B,EAGE;;AAEA,MAAA,OAAO,CAAC,IAAR,CACE,+FADF;AAGD;;AACD,WAAO;AACL,MAAA,MAAM,EAAG,MAAM,MAAM,CAAC,QAAP,CAAgB,MAAhB,EAAsB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAChC,OADgC,CAAA,EACzB;AACV,QAAA;AADU,OADyB,CAAtB,CADV;AAKL,MAAA,MAAM,EAAE;AALH,KAAP;AAOD,GAjBD,CAiBE,OAAO,CAAP,EAAU;AACV,UAAM,YAAY,GAAG,gBAAgB,CAAC,CAAD,EAAI,wBAAJ,CAArC;AACA,WAAO;AACL,MAAA,MAAM,EAAE,EADH;AAEL,MAAA,MAAM,EAAE,wBAAwB,GAC5B,YAD4B,GAE5B,qBAAqB,CAAC,YAAD;AAJpB,KAAP;AAMD;AACH,C;;AC7EA,IAAA,sBAAA,GAAgB,KAAD,IACb,KAAK,CACF,MADH,CAEI,CAAC,QAAD,EAAW,IAAX,EAAkC,KAAlC,KACE,GAAG,QAAQ,GACT,OAAO,IAAP,KAAgB,QAAhB,GACI,GAAG,KAAK,GAAG,CAAR,GAAY,GAAZ,GAAkB,EAAE,GAAG,IAAI,EADlC,GAEI,IAAI,IAAI,GACd,EAPN,EAQI,EARJ,EAUG,QAVH,EADF;;ACIA,MAAMA,kBAAgB,GAAG,CACvB,KADuB,EAEvB,wBAFuB,KAIvB,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,QAApB,IACI,KAAK,CAAC,QAAN,CAAe,MAAf,CACE,CAAC,QAAD,EAAgC;AAAE,EAAA,IAAF;AAAQ,EAAA,OAAO,GAAG,EAAlB;AAAsB,EAAA;AAAtB,CAAhC,KAA4D;AAC1D,QAAM,WAAW,GAAG,sBAAsB,CAAC,IAAD,CAA1C;AAEA,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,QADL,CAAA,EAEM,IAAI,GACJ,QAAQ,CAAC,WAAD,CAAR,IAAyB,wBAAzB,GACE;AACE,KAAC,WAAD,GAAe,YAAY,CACzB,WADyB,EAEzB,wBAFyB,EAGzB,QAHyB,EAIzB,IAAI,IAAI,EAJiB,EAKzB,OALyB;AAD7B,GADF,GAUE;AACE,KAAC,WAAD,GAAe,QAAQ,CAAC,WAAD,CAAR,IAAqB,MAAA,CAAA,MAAA,CAAA;AAClC,MAAA,OADkC;AAElC,MAAA;AAFkC,KAAA,EAG9B,wBAAwB,GACxB;AACE,MAAA,KAAK,EAAE;AAAE,SAAC,IAAI,IAAI,EAAT,GAAc,OAAO,IAAI;AAA3B;AADT,KADwB,GAIxB,EAP8B;AADtC,GAXE,GAsBJ,EAxBN,CAAA;AA0BD,CA9BH,EA+BE,EA/BF,CADJ,GAkCI,EAtCN;;MAwCa,mBAAmB,GAC9B,MADiC,IAEN,OAC3B,MAD2B,EAE3B,CAF2B,EAG3B,wBAAwB,GAAG,KAHA,KAGK;AAEhC,MAAI;AACF,WAAO;AACL,MAAA,MAAM,EAAE,MAAM,CAAC,MAAD,CADT;AAEL,MAAA,MAAM,EAAE;AAFH,KAAP;AAID,GALD,CAKE,OAAO,CAAP,EAAU;AACV,WAAO;AACL,MAAA,MAAM,EAAE,EADH;AAEL,MAAA,MAAM,EAAE,qBAAqB,CAC3BA,kBAAgB,CAAC,CAAD,EAAI,wBAAJ,CADW;AAFxB,KAAP;AAMD;AACH,C;;AC5DA,MAAMA,kBAAgB,GAAG,CACvB,KADuB,EAEvB,wBAFuB,KAIvB,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,OAApB,IACI,KAAK,CAAC,OAAN,CAAc,MAAd,CACE,CAAC,QAAD,EAAgC;AAAE,EAAA,IAAF;AAAQ,EAAA,OAAO,GAAG,EAAlB;AAAsB,EAAA;AAAtB,CAAhC,KAA4D;AAC1D,QAAM,WAAW,GAAG,sBAAsB,CAAC,IAAD,CAA1C;AAEA,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,QADL,CAAA,EAEM,IAAI,GACJ,QAAQ,CAAC,WAAD,CAAR,IAAyB,wBAAzB,GACE;AACE,KAAC,WAAD,GAAe,YAAY,CACzB,WADyB,EAEzB,wBAFyB,EAGzB,QAHyB,EAIzB,IAJyB,EAKzB,OALyB;AAD7B,GADF,GAUE;AACE,KAAC,WAAD,GAAe,QAAQ,CAAC,WAAD,CAAR,IAAqB,MAAA,CAAA,MAAA,CAAA;AAClC,MAAA,OADkC;AAElC,MAAA;AAFkC,KAAA,EAG9B,wBAAwB,GACxB;AACE,MAAA,KAAK,EAAE;AAAE,SAAC,IAAD,GAAQ,OAAO,IAAI;AAArB;AADT,KADwB,GAIxB,EAP8B;AADtC,GAXE,GAsBJ,EAxBN,CAAA;AA0BD,CA9BH,EA+BE,EA/BF,CADJ,GAkCI,EAtCN;;MAwCa,WAAW,GAAG,CACzB,MADyB,EAEzB,OAAA,GAAsC;AACpC,EAAA,UAAU,EAAE;AADwB,CAFb,KAKE,OAC3B,MAD2B,EAE3B,CAF2B,EAG3B,wBAAwB,GAAG,KAHA,KAGK;AAEhC,MAAI;AACF,WAAO;AACL,MAAA,MAAM,EAAE,MAAM,MAAM,CAAC,aAAP,CAAqB,MAArB,EAA2B,MAAA,CAAA,MAAA,CAAA,EAAA,EACpC,OADoC,CAA3B,CADT;AAIL,MAAA,MAAM,EAAE;AAJH,KAAP;AAMD,GAPD,CAOE,OAAO,CAAP,EAAU;AACV,WAAO;AACL,MAAA,MAAM,EAAE,EADH;AAEL,MAAA,MAAM,EAAE,qBAAqB,CAC3BA,kBAAgB,CAAC,CAAD,EAAI,wBAAJ,CADW;AAFxB,KAAP;AAMD;AACH,C","sourcesContent":["import { Resolver, transformToNestObject } from 'react-hook-form';\nimport Yup from 'yup';\n\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          return {\n            ...previous,\n            ...(path\n              ? {\n                  [path]: {\n                    ...(previous[path] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            [type]: previousTypes[type]\n                              ? [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        [error.path]: { message: error.message, type: error.type },\n      };\n\nexport const yupResolver = <TFieldValues extends Record<string, any>>(\n  schema: Yup.ObjectSchema | Yup.Lazy,\n  options: Omit<Yup.ValidateOptions, 'context'> = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (\n      (options as Yup.ValidateOptions).context &&\n      process.env.NODE_ENV === 'development'\n    ) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: (await schema.validate(values, {\n        ...options,\n        context,\n      })) as any,\n      errors: {},\n    };\n  } catch (e) {\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: validateAllFieldCriteria\n        ? parsedErrors\n        : transformToNestObject(parsedErrors),\n    };\n  }\n};\n","export default (paths: (string | number)[]): string =>\n  paths\n    .reduce(\n      (previous, path: string | number, index): string =>\n        `${previous}${\n          typeof path === 'string'\n            ? `${index > 0 ? '.' : ''}${path}`\n            : `[${path}]`\n        }`,\n      '',\n    )\n    .toString();\n","import { appendErrors, transformToNestObject, Resolver } from 'react-hook-form';\nimport Superstruct from 'superstruct';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: Superstruct.StructError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.failures)\n    ? error.failures.reduce(\n        (previous: Record<string, any>, { path, message = '', type }) => {\n          const currentPath = convertArrayToPathName(path);\n\n          return {\n            ...previous,\n            ...(path\n              ? previous[currentPath] && validateAllFieldCriteria\n                ? {\n                    [currentPath]: appendErrors(\n                      currentPath,\n                      validateAllFieldCriteria,\n                      previous,\n                      type || '',\n                      message,\n                    ),\n                  }\n                : {\n                    [currentPath]: previous[currentPath] || {\n                      message,\n                      type,\n                      ...(validateAllFieldCriteria\n                        ? {\n                            types: { [type || '']: message || true },\n                          }\n                        : {}),\n                    },\n                  }\n              : {}),\n          };\n        },\n        {},\n      )\n    : [];\n\nexport const superstructResolver = <TFieldValues extends Record<string, any>>(\n  schema: Superstruct.Struct,\n): Resolver<TFieldValues> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    return {\n      values: schema(values),\n      errors: {},\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(e, validateAllFieldCriteria),\n      ),\n    };\n  }\n};\n","import { appendErrors, transformToNestObject, Resolver } from 'react-hook-form';\nimport Joi from '@hapi/joi';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: Joi.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.details)\n    ? error.details.reduce(\n        (previous: Record<string, any>, { path, message = '', type }) => {\n          const currentPath = convertArrayToPathName(path);\n\n          return {\n            ...previous,\n            ...(path\n              ? previous[currentPath] && validateAllFieldCriteria\n                ? {\n                    [currentPath]: appendErrors(\n                      currentPath,\n                      validateAllFieldCriteria,\n                      previous,\n                      type,\n                      message,\n                    ),\n                  }\n                : {\n                    [currentPath]: previous[currentPath] || {\n                      message,\n                      type,\n                      ...(validateAllFieldCriteria\n                        ? {\n                            types: { [type]: message || true },\n                          }\n                        : {}),\n                    },\n                  }\n              : {}),\n          };\n        },\n        {},\n      )\n    : [];\n\nexport const joiResolver = <TFieldValues extends Record<string, any>>(\n  schema: Joi.Schema,\n  options: Joi.AsyncValidationOptions = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    return {\n      values: await schema.validateAsync(values, {\n        ...options,\n      }),\n      errors: {},\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(e, validateAllFieldCriteria),\n      ),\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}